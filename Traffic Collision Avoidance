class Puck:

    RADIUS = 1.0

    def __str__(self):
        return f"Puck(Id={self.id}, Alive={self.alive}, "\
               f"s={self.s}, v={self.v}, a={self.a}"

    def is_alive(self):
        return self.alive

    def get_id(self):
        return self.id

    def get_time(self):
        return self.t

    def get_position(self):
        return self.s

    def get_velocity(self):
        return self.v

    def get_acceleration(self):
        return self.a

    def get_name(self):
        return self.name

    def get_fuel(self):
        return self.fuel

    def get_points(self):
        return self.points


class Box:

    def __str__(self):
        return f"Box(xmin={self.xmin}, xmax={self.xmax}, "\
                   f"ymin={self.ymin}, ymax={self.ymax})"

    def get_x_limits(self):
        return (self.xmin, self.xmax)

    def get_y_limits(self):
        return (self.ymin, self.ymax)

# berechnet den Betrag eines zweidimensionalen Vektors
import math as m
def betrag(x, y):
    return m.sqrt(x**2 + y**2) #wenn die beschleunigung negativ ist?

def worker_shambayati(id, secret, q_request, q_reply):
    
    V_MIN =  10.0
    V_MAX =  42.0
    A_MAX = 100.0

    q_request.put(('SET_NAME', 'shambayati', secret, id))

    # eigenen Puck rausfinden
    q_request.put(('GET_SIZE', id))
    size = q_reply.get()[1]
    for n in range(0, size-1):
        q_request.put(('GET_PUCK', n, id))
        puck = q_reply.get()[1]
        if puck.get_id() == id:
            puck_self = n
            break

    # Grenzen abfragen
    q_request.put((’GET BOX’,  id))
    grenzen = q_reply.get(’GET BOX’, box)
    x_koordinaten = box.get_x_limits()
    xmin = x_koordinaten[0]
    xmax = x_koordinaten[1]
    y_koordinaten = box.get_y_limits()
    ymin = y_koordinaten[0]
    ymax = y_koordinaten[1]

    # Verhalten nach einer Reflexion
    s = puck.get_position()
    if s[0]-Puck.RADIUS == xmin or s[0]+Puck.RADIUS == xmax or s[1]-Puck.RADIUS == ymin or s[1]+Puck.RADIUS == ymax:
        #mehrere Abfragen

    # Geschwindigkeit abfragen
    v_vektor = puck.get_velocity()
    v = betrag(v_vektor)

    import numpy as np
    # Geschwindigkeitsgrenzen nicht überschreiten
    if v == V_MIN + 1:
        q_request.put(’SET_ACCELERATION’, np.array ([1, 1]), secret, id)
        q_reply.get(’SET_ACCELERATION’, a)
        q_request.put(’SET_ACCELERATION’, np.array ([0,0]), secret, id)
    if v == V_MAX - 1:
        q_request.put(’SET_ACCELERATION’,np.array (-[1, 1]) , secret, id)
        q_reply.get(’SET_ACCELERATION’, a)
        q_request.put(’SET_ACCELERATION’, np.array ([0,0]), secret, id)

    s = ort
    d = abstand
    v = geschwindigkeit
    a = beschleunugung
    t = Zeit

    # verhalten bei möglicher Kollision
    del_v = v_1,o-v_2,0
    del_r = r_1,0-r_2,0
    t_ca = - del_r*del_v/ del_v*del_v
    r_ca = del_r-(del_r*del_v)/del_v*del_v)*del_v
    a = 2*(2.5-r_ca) / t_ca**2
    
    
    
def main():
    # die request queue erzeugen
    manager = mp.Manager()
    q_request = manager.Queue()

    # Queues erzeugen
    q_reply = Queue()
    q_request = Queue()

if __name__ == "__main__":
    main()
