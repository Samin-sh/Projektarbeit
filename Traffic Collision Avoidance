class Puck:

    RADIUS = 1.0

    def __str__(self):
        return f"Puck(Id={self.id}, Alive={self.alive}, "\
               f"s={self.s}, v={self.v}, a={self.a}"

    def is_alive(self):
        return self.alive

    def get_id(self):
        return self.id

    def get_time(self):
        return self.t

    def get_position(self):
        return self.s

    def get_velocity(self):
        return self.v

    def get_acceleration(self):
        return self.a

    def get_name(self):
        return self.name

    def get_fuel(self):
        return self.fuel

    def get_points(self):
        return self.points


class Box:

    def __str__(self):
        return f"Box(xmin={self.xmin}, xmax={self.xmax}, "\
                   f"ymin={self.ymin}, ymax={self.ymax})"

    def get_x_limits(self):
        return (self.xmin, self.xmax)

    def get_y_limits(self):
        return (self.ymin, self.ymax)

# berechnet den Betrag eines zweidimensionalen Vektors
import math as m
def betrag(x, y):
    return m.sqrt(x**2 + y**2) #wenn die beschleunigung negativ ist?

def worker_shambayatai(id, secret, q_request, q_reply):
    
    V_MIN =  10.0
    V_MAX =  42.0
    A_MAX = 100.0

    q_request.put((’SET_NAME’, shambayati, secret, id))

    # Grenzen abfragen
    q_request.put((’GET BOX’,  id))
    grenzen = q_reply.get(’GET BOX’, box)
    x_koordinaten = box.get_x_limits()
    xmin = x_koordinaten[0]
    xmax = x_koordinaten[1]
    y_koordinaten = box.get_y_limits()
    ymin = y_koordinaten[0]
    ymax = y_koordinaten[1]

    # Verhalten nach einer Reflexion
    s = puck.get_position()
    if s[0] == xmin or s[0] == xmax or s[1] == ymin or s[1] == ymax:
        #mehrere Abfragen

    # Geschwindigkeit abfragen
    v_vektor = puck.get_velocity()
    v = betrag(v_vektor)

    # Geschwindigkeitsgrenzen nicht überschreiten
    if v == V_MIN + 1:
        q_request.put(’SET_ACCELERATION’, [1, 1], secret, id)
        q_reply.get(’SET_ACCELERATION’, a)
        q_request.put(’SET_ACCELERATION’, [0,0], secret, id)
    if v == V_MAX - 1:
        q_request.put(’SET_ACCELERATION’,[-1, 1] , secret, id)
        q_reply.get(’SET_ACCELERATION’, a)
        q_request.put(’SET_ACCELERATION’, [0,0], secret, id)

    # Funktion für Position mit Beschleunigung
    r(t) = r0+ 1/2 a t^2
    import multiprocessing as mp 
    # die request queue erzeugen
    manager = mp.Manager()
    q_request = manager.Queue()

def main():

    # Queues erzeugen
    q_reply = Queue()
    q_request = Queue()

if __name__ == "__main__":
    main()